Paillier Example
================

Homomorphic Encryption
----------------------------

A homomorphic encryption scheme, generally, allows one to compute on ciphertexts, where the plaintexts are not known, and get a new ciphertext which is the encryption of the result generated by some operation on the original plaintext. More specifically, assume the encryption algorithm is :math:`E(x)`, where :math:`x` is a plaintext, then a homomorphic encryption scheme promises that

.. math::

  E(x) \oplus E(y) = E(x \circ y)

where :math:`x, y` are two plaintexts, :math:`\oplus` an operation on ciphertexts, :math:`\circ` an operation on plaintexts, usually arithmetic or logical *addition or multiplication*. We can call the operation over ciphertexts an *evaluation* of the plaintext operation.

When a homomorphic encryption scheme supports addition and multiplication simultaneously, that is to say, 

.. math::

  \begin{aligned}
    E(x) \oplus E(y) = & E(x + y) \\
    E(x) \otimes E(y) = & E(xy)
  \end{aligned}

the scheme is called a **fully homomorphic encryption (FHE)** scheme; otherwise, when only one operation is supported, the scheme is called a **partially homomorphic encryption (PHE)** scheme.

Paillier Homomorphic Encryption Scheme
-------------------------------------------

Pascal Paillier introduced a *partially* HE scheme in 1999, which supports the multiplication over ciphertexts corresponding to addition over plaintexts.

We will go through a simple implementation of this scheme using *python*, and address the correctness of the scheme in the last part of this tutorial. Should you wish to go directly with the codes, you could check out the Jupyter Notebook we provided over Github. (notebooks/paillier.ipynb)

An implementation of Paillier HE
----------------------------------

Mathematic basics
^^^^^^^^^^^^^^^^^^^^^^^

First we implement quick-power, extended Euclidean Algorithm, and a function to get the multiplication inverse under some modulo. 

.. code-block:: python
  
  import random
  import math

  # quick power: calculate (base^exponent)%modulus
  def powerMod(base, exponent, modulus):
    answer = 1
    while exponent > 0:
      if exponent % 2 == 1: answer = (answer * base) % modulus
      base = (base**2) % modulus
      exponent //= 2
    return answer

  # exgcd: return (x, y, gcd(a, b)) where ax + by = gcd(a,b)
  def exgcd(a, b):
    if b == 0: return 1, 0, a
    else:
      x0, y0, g = exgcd(b, a%b)
      return y0, x0 - (a//b)*y0, g

  # inv: return x, where ax = 1 (mod m)
  def inv(a, m) -> int:
      x, y, g = exgcd(a, m)
      return (x%m+m)%m

As the key generation uses large primes, we use the Sieve of Eratosthenes to calculate a list of primes for simplicity. 

.. code-block:: python

  def sieve(upperbound = 0x4000):
    primes = []
    flags = [True] * upperbound
    for each in range(2, upperbound):
      if not flags[each]: continue
      for multiplier in range(2, upperbound // each):
        flags[multiplier * each] = False
      primes.append(each)
    return primes

  primes = sieve(0x4000)

.. note::
  Empirically, to find a prime great enough, **Miller-Rabin primality test** is usually used. Its essence is to generate randomly a number and if the number passes some simple mathematical tests, it can be treated as a prime number with a high probability. 

Key Generation
^^^^^^^^^^^^^^^^^^^^

To generate a set of keys in Paillier HE,

#. randomly select two large primes :math:`p, q`, and calculate :math:`n=pq, \lambda=\text{lcm}(p-1, q-1)`;
#. select :math:`g < n^2`, where :math:`g` and :math:`n` are coprime, and the multiplication inverse under modulo :math:`n`

   .. math::

     \mu \cdot L(g^\lambda \text{ mod } n^2) \equiv 1 \pmod {n}

   exists, where :math:`L(x) = (x-1)/n`;

#. then the public key is :math:`(n, g)`, the private key :math:`(\lambda, \mu)`.

.. note::
  
  Empirically, as :math:`g` is public, we need not choose it *randomly*. For example we can actually set :math:`g = n+1`. As we would see later, such :math:`g` guarantees that :math:`L(g^\lambda \text{ mod } n^2)` is indeed an integer.

.. code:: python

  # produce (n, g, lambda, mu), where (n, g) is the public key, (lambda, mu) is the private key
  def generateKeys():
    primeCount = len(primes)
    p = primes[random.randint(primeCount // 2, primeCount)]
    while True:
      q = primes[random.randint(primeCount // 2, primeCount)]
      if p != q: break
    n = p*q
    Lambda = (p-1)*(q-1) // math.gcd(p-1, q-1)
    g = n + 1
    mu = inv((powerMod(g, Lambda, n*n)-1)//n, n)
    return n, g, Lambda, mu

Encryption
^^^^^^^^^^^^^^^^^^^^^^^

To encrypt some plaintext :math:`m < n`, randomly select :math:`0 < r < n` such that :math:`r` and :math:`n` are coprime, and the ciphertext can be calculated as :math:`c = g^m r^n (\text{mod } n^2)`.

.. note::
  In fact, when :math:`n` is large enough, we can uniformly samples a :math:`0 < r < n`, for it is very unlikely that the two numbers are not coprime.

.. code:: python

  def encrypt(m, n, g):
    while True:
      r = random.randint(1, n-1)
      if math.gcd(r, n) == 1: break
    c = powerMod(g, m, n*n) * powerMod(r, n, n*n) % (n*n)
    return c

Decryption
^^^^^^^^^^^^^^^^^^^^^^^^^

To decrpyt a ciphertext :math:`c`, calculate the plaintext as :math:`m = \mu \cdot L(c^\lambda \text{ mod } n^2) \text{ mod } n`.

.. code:: python

  def decrypt(c, Lambda, mu, n):
    k = powerMod(c, Lambda, n*n)
    assert((k-1)%n == 0) # when (k-1)%n != 0, c is not a valid ciphertext.
    return (k-1)//n * mu % n  

Evaluation of the Addition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For two ciphertexts :math:`c_1`, :math:`c_2`, calculate :math:`c_3 = c_1 \cdot c_2 \text{ mod } n^2`. Then :math:`c_3` is a valid ciphertext, and 

.. math::
  D(c_3) = D(c_1) + D(c_2)

where :math:`D(c)` is the decryption algorithm.

.. code:: python

  def evalAdd(c1, c2, n):
    return c1 * c2 % (n*n)

Testing
^^^^^^^^^^^^^^^^^^^^

With the codes above, we can test the correctness of our implementation.

.. code:: python

  # generate keys
  n, g, Lambda, mu = generateKeys()
  print(f"Public key:       n = {n:10d},  g = {g:10d}")
  print(f"Private key: lambda = {Lambda:10d}, mu = {mu:10d}")

  # plaintext
  m1 = random.randint(0, n-1)
  m2 = random.randint(0, n-1)

  # ciphertext
  c1 = encrypt(m1, n, g)
  c2 = encrypt(m2, n, g)
  print(f"c1 = Encrypt({m1}) = {c1:18d} = 0x{c1:015x}")
  print(f"c2 = Encrypt({m2}) = {c2:18d} = 0x{c2:015x}")

  # evaluate addition
  c3 = evalAdd(c1, c2, n)
  print(f"c3 = c1 * c2 = {c3:18d} = 0x{c3:015x}")

  # decrypt
  d = decrypt(c3, Lambda, mu, n)
  print(f"Decrypt(c3) = {d} = {m1} + {m2} (mod {n})")

We provide a Jupyter Nodebook on Github repo should you wish to check the full code. (notebooks/paillier.ipynb)

Correctness of Paillier HE Scheme
--------------------------------------

Encryption and Decryption
^^^^^^^^^^^^^^^^^^^^^^^^^^^

As :math:`\lambda = \text{lcm}(p-1, q-1)`, we can denote that :math:`\lambda = k_1(p-1) = k_2(q-1)`.

Because :math:`g` is not a multiple of :math:`p`, by Fermat's Little Theorem we have that :math:`g^{\lambda} = g^{k_1 (p-1)} \equiv 1 \pmod{p}`; similiarly :math:`g^{\lambda} \equiv 1 \pmod{q}`; therefore, :math:`g^\lambda \equiv 1 \pmod{n}`; that is to say :math:`g^\lambda \text{ mod } n^2 \equiv 1 \pmod{n}`. Let :math:`g^\lambda \text{ mod } n^2 = kn + 1`, namely :math:`L(g^\lambda \text{ mod } n^2) = k`.

The Binomial Theorem gives that, :math:`(1 + kn)^m \equiv knm + 1 \pmod{n^2}`; hence, :math:`g^{m\lambda} \equiv (kn+1)^m \equiv knm + 1 \pmod{n^2}`.

Similarly, as :math:`\gcd(r, n) = 1`, then :math:`r^\lambda \equiv 1`, denoted by :math:`r^\lambda = k_r n + 1`. Therefore, :math:`r^{\lambda n} \equiv k_r n^2 + 1 \equiv 1 \pmod {n^2}`.

Consequently, :math:`L(g^{m\lambda}r^{n\lambda} \text{ mod } n^2) = L(knm + 1) = km`, and :math:`\mu L(g^{m\lambda}r^{n\lambda} \text{ mod } n^2) \equiv km / k \equiv m \pmod{n}`. That is to say, the decryption of a ciphertext is indeed the original plaintext.

Evaluation of the Addition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let two ciphertexts be :math:`c_1 = g^{m_1}r_1^n \text{ mod } n^2, c_2 = g^{m_2}r_2^n \text{ mod } n^2`, and :math:`c_3 \equiv c_1c_2  \equiv g^{m_1+m_2} r_1^n r_2^n \pmod{n^2}`.

By the analysis stated in the previous section, :math:`g^{(m_1+m_2)\lambda} \equiv kn(m_1+m_2) + 1`, and :math:`r_1^{\lambda n} \equiv r_2^{\lambda n} \equiv 1 \pmod{n^2}`. So we can easily deduce that :math:`\mu L(c_3^\lambda  \text{ mod } n^2) \equiv k(m_1+m_2) / k \equiv m_1 + m_2 \pmod{n}`. That is to say, the evaluation of the addition operation holds.